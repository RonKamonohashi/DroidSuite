#!/bin/bash

# ====================================== #
# DroidSuite ADB-powered Android toolkit #
# ====================================== #


# =============================================================================
# GLOBAL VARIABLES AND SETUP
# =============================================================================

# Colors for output formatting
# These are ANSI escape codes for colored terminal output.
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
NC='\033[0m'  # No Color

# Clean up ADB server on script termination
# This trap ensures the ADB server is stopped if the script is interrupted (Ctrl+C) or terminated.
trap 'adb kill-server &>/dev/null; echo -e "${RED}Script terminated. ADB server stopped.${NC}"; exit 1' SIGINT SIGTERM
# This trap stops the ADB server on normal exit.
trap 'adb kill-server &>/dev/null' EXIT

# Get script directory
# This determines the directory where the script is located, using realpath for absolute path.
SCRIPT_DIR=$(dirname "$(realpath "$0")")

# =============================================================================
# INITIALIZATION AND SETUP FUNCTIONS
# =============================================================================

# Check device connection
# This function starts the ADB server and checks if a device is connected and authorized.
# Returns 0 if connected, 1 otherwise.
check_device_connection() {
  # Start ADB server silently, return error if it fails.
  adb start-server &>/dev/null || { echo -e "${RED}ADB server failed to start.${NC}"; return 1; }
  # Check if 'adb devices' shows a connected device (ends with "device").
  if ! adb devices | grep -q "device$"; then
    echo -e "${RED}No device connected. Please reconnect using the connection menu.${NC}"
    return 1
  fi
  # If checks pass, device is connected.
  return 0
}

# This function checks for ADB and promts the user with a install command when adb is not found
# Supports Arch and Debian-based distributions.
check_for_adb() {
  # Check if ADB is already installed.
  if command -v adb >/dev/null 2>&1; then
    return 0
  fi
  echo -e "${RED}ADB not found.${NC}"
  # Check for /etc/os-release to detect distribution.
  if [ ! -f /etc/os-release ]; then
    echo -e "${RED}Unable to detect distribution. Please install adb.${NC}"
    exit 1
  fi
  # Source the os-release file to get distribution info.
  . /etc/os-release
  # Arch-based: Use pacman
  if command -v pacman >/dev/null 2>&1; then
    echo -e "${GREEN}Arch-based distribution detected.${NC}"
    echo -e "${YELLOW}Run the following command to install: sudo pacman -S android-tools${NC}"
    exit 1
  # Debian-based (only installs adb)
  elif command -v apt >/dev/null 2>&1; then
    echo -e "${GREEN}Debian-based distribution detected.${NC}"
    echo -e "${YELLOW}Run the following command to install: sudo apt install -y android-tools-adb${NC}"
    exit 1
  else
    # Unsupported distribution.
    echo -e "${RED}Unsupported distribution (${ID:-unknown}). Please install adb.${NC}"
    exit 1
  fi
}

# Helper function to check if device is rooted
# Runs 'su -c echo yes' and checks output.
# Returns 0 if rooted, 1 otherwise.
is_rooted() {
  local test=$(adb shell "su -c 'echo yes' 2>/dev/null" | tr -d '\r')
  if [[ "$test" == "yes" ]]; then
    return 0
  else
    return 1
  fi
}

# =============================================================================
# ADB CONNECTION FUNCTIONS
# =============================================================================

# Connect via USB
# Attempts to connect via USB with retries for unauthorized or missing devices.
# Returns 0 on success, 1 on failure.
connect_usb() {
  # Kill and restart ADB server.
  adb kill-server
  adb start-server || { echo -e "${RED}Failed to start ADB server. Check permissions or port conflicts.${NC}"; exit 1; }
  echo -e "${GREEN}Looking for USB devices...${NC}"
  # Retry up to 3 times.
  for i in {1..3}; do
    adb devices
    if adb devices | grep -q "unauthorized"; then
      # Handle unauthorized device.
      echo -e "${RED}Device unauthorized. Please accept the ADB connection on your device (attempt $i/3).${NC}"
      sleep 10
      adb kill-server
      adb start-server || { echo -e "${RED}Failed to start ADB server. Check permissions or port conflicts.${NC}"; exit 1; }
    elif adb devices | grep -q "device$"; then
      # Success if device is detected.
      echo -e "${GREEN}Connected via USB.${NC}"
      return 0
    else
      # Retry if no device found.
      echo -e "${RED}No device found via USB (attempt $i/3).${NC}"
      sleep 5
      adb kill-server
      adb start-server || { echo -e "${RED}Failed to start ADB server. Check permissions or port conflicts.${NC}"; exit 1; }
    fi
  done
  # Failure after retries.
  echo -e "${RED}Failed to connect via USB after 3 attempts.${NC}"
  return 1
}

# Connect via IP
# Allows fresh connection or from history, with IP validation and history saving.
# Calls main_menu on success, returns 1 on failure.
connect_ip() {
  # Set history file path.
  SCRIPT_DIR=$(dirname "$0")
  HISTORY_FILE="$SCRIPT_DIR/DroidSuiteConnections.txt"
  while true; do
    echo "Choose connection type:"
    echo "1) Fresh connection"
    echo "2) Connect from history"
    read -r -p "Enter choice (1 or 2): " choice
    if [[ "$choice" == "1" ]]; then
      # Fresh connection: Validate IP and ping.
      while true; do
        read -r -p "Enter device IP address: " device_ip
        # Validate IP format.
        if [[ ! "$device_ip" =~ ^([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$ ]] ||
           [[ ${BASH_REMATCH[1]} -gt 255 || ${BASH_REMATCH[2]} -gt 255 || ${BASH_REMATCH[3]} -gt 255 || ${BASH_REMATCH[4]} -gt 255 ]]; then
          echo -e "${RED}Invalid IP address: $device_ip${NC}"
          continue
        fi
        # Check if IP is reachable.
        if ping -c 1 -W 1 "$device_ip" > /dev/null 2>&1; then
          break
        else
          echo -e "${RED}IP address $device_ip is not reachable via ping. Please re-enter a valid IP.${NC}"
          continue
        fi
      done
      break
    elif [[ "$choice" == "2" ]]; then
      # Connect from history: Load and display history.
      if [[ ! -f "$HISTORY_FILE" ]] || [[ ! -s "$HISTORY_FILE" ]]; then
        echo -e "${RED}No connection history available.${NC}"
        continue
      fi
      mapfile -t histories < "$HISTORY_FILE"
      if [[ ${#histories[@]} -eq 0 ]]; then
        echo -e "${RED}No connection history available.${NC}"
        continue
      fi
      echo "Available connections:"
      for i in "${!histories[@]}"; do
        ip="${histories[i]%%|*}"
        name="${histories[i]#*|}"
        echo "$((i+1))) $name ($ip)"
      done
      read -r -p "Enter choice: " hist_choice
      if [[ "$hist_choice" =~ ^[0-9]+$ ]] && [[ "$hist_choice" -ge 1 ]] && [[ "$hist_choice" -le ${#histories[@]} ]]; then
        selected="${histories[((hist_choice-1))]}"
        device_ip="${selected%%|*}"
        device_name="${selected#*|}"
      else
        echo -e "${RED}Invalid choice.${NC}"
        continue
      fi
      # Check if historical IP is reachable.
      if ! ping -c 1 -W 1 "$device_ip" > /dev/null 2>&1; then
        echo -e "${RED}IP address $device_ip ($device_name) from history is not reachable via ping.${NC}"
        continue
      fi
      break
    else
      echo -e "${RED}Invalid choice. Please select 1 or 2.${NC}"
      continue
    fi
  done
  # Kill and restart ADB server.
  adb kill-server
  adb start-server || { echo -e "${RED}Failed to start ADB server. Check permissions or port conflicts.${NC}"; exit 1; }
  echo -e "${GREEN}Connecting to $device_ip...${NC}"
  # Retry connection up to 3 times.
  for i in {1..3}; do
    adb connect "$device_ip" || { sleep 5; adb kill-server; adb start-server || { echo -e "${RED}Failed to start ADB server. Check permissions or port conflicts.${NC}"; exit 1; }; continue; }
    sleep 3
    if adb devices | grep -q "$device_ip.*unauthorized"; then
      # Handle unauthorized.
      echo -e "${RED}Device unauthorized. Please accept the ADB connection on your device (attempt $i/3).${NC}"
      sleep 10
      adb kill-server
      adb start-server || { echo -e "${RED}Failed to start ADB server. Check permissions or port conflicts.${NC}"; exit 1; }
    elif adb devices | grep -q "$device_ip.*device"; then
      # Success.
      echo -e "${GREEN}Connected via IP.${NC}"
      if [[ "$choice" == "1" ]]; then
        # Save to history if fresh connection.
        while true; do
          read -r -p "Save this connection to history? (y/n): " save
          if [[ "$save" =~ ^[yY]$ ]]; then
            if [[ -f "$HISTORY_FILE" ]] && grep -q "^${device_ip}|" "$HISTORY_FILE"; then
              echo -e "${YELLOW}IP already in history. Press enter to skip saving and proceed.${NC}"
              read -r
              break
            else
              while true; do
                read -r -p "Enter custom name for this device: " name
                if [[ -n "$name" ]]; then
                  echo "${device_ip}|${name}" >> "$HISTORY_FILE"
                  filename="DroidSuiteConnections.txt"
                  echo "Connection saved to $SCRIPT_DIR/$filename."
                  echo "Press enter to continue"
                  read -r
                  break
                else
                  echo -e "${RED}No name provided. Please enter a name or press Ctrl+C to cancel.${NC}"
                fi
              done
              break
            fi
          elif [[ "$save" =~ ^[nN]$ ]]; then
            break
          else
            echo -e "${RED}Invalid choice. Please enter y or n.${NC}"
          fi
        done
      fi
      main_menu
      return 0 # Fallback: keep return in case main_menu returns.
    else
      sleep 5
      adb kill-server
      adb start-server || { echo -e "${RED}Failed to start ADB server. Check permissions or port conflicts.${NC}"; exit 1; }
    fi
  done
  return 1
}

connection_menu() {
  clear
  echo -e
  echo -e "${GREEN}Select connection method:${NC}"
  echo "1) USB"
  echo "2) IP"
  echo "3) Exit"
  read -r -p "Choose (1-3): " c
  case $c in
    1) connect_usb || { echo -e "${RED}Connection failed. Exiting.${NC}"; exit 1; } ;;
    2) connect_ip || { echo -e "${RED}Connection failed. Exiting.${NC}"; exit 1; } ;;
    3) echo "Exiting."; exit 0 ;;
    *) echo -e "${RED}Invalid choice.${NC}" ; connection_menu ;;
  esac
}

# =============================================================================
# DEVICE INFORMATION FUNCTIONS
# =============================================================================

show_device_report() {
  # Ensure device is connected.
  check_device_connection || return 1
  SCRIPT_DIR=$(dirname "$(realpath "$0")")
  clear
  local report=""
  echo -e "\n${GREEN}=== Device System Report ===${NC}"
  report+=$'\n=== Device System Report ===\n'
  echo
  report+=$'\n'
  # === Basic Device Info ===
  echo -e "${GREEN}Device Info${NC}"
  report+="Device Info"$'\n'
  # Retrieve various properties using getprop.
  local brand=$(adb shell getprop ro.product.brand 2>/dev/null | tr -d '\r' | xargs)
  local model=$(adb shell getprop ro.product.model 2>/dev/null | tr -d '\r' | xargs)
  local release=$(adb shell getprop ro.build.version.release 2>/dev/null | tr -d '\r' | xargs)
  local sdk=$(adb shell getprop ro.build.version.sdk 2>/dev/null | tr -d '\r' | xargs)
  local serial=$(adb shell getprop ro.serialno 2>/dev/null | tr -d '\r' | xargs)
  local build=$(adb shell getprop ro.build.display.id 2>/dev/null | tr -d '\r' | xargs)
  local security_patch=$(adb shell getprop ro.build.version.security_patch 2>/dev/null | tr -d '\r' | xargs)
  local kernel=$(adb shell uname -r 2>/dev/null | tr -d '\r' | xargs)
  local arch=$(adb shell getprop ro.product.cpu.abi 2>/dev/null | tr -d '\r' | xargs)
  local arch_list=$(adb shell getprop ro.product.cpu.abilist 2>/dev/null | tr -d '\r' | xargs)
  local rooted="No"
  # Check for root.
  if is_rooted; then
    rooted="Yes"
  fi
  # Display basic info.
  echo " Brand: ${brand:-Unknown}"
  report+=" Brand: ${brand:-Unknown}"$'\n'
  echo " Model: ${model:-Unknown}"
  report+=" Model: ${model:-Unknown}"$'\n'
  echo " Android: ${release:-Unknown} (SDK ${sdk:-?})"
  report+=" Android: ${release:-Unknown} (SDK ${sdk:-?})"$'\n'
  echo " Serial: ${serial:-Unknown}"
  report+=" Serial: ${serial:-Unknown}"$'\n'
  echo " Build: ${build:-Unknown}"
  report+=" Build: ${build:-Unknown}"$'\n'
  echo " Patch: ${security_patch:-Unknown}"
  report+=" Patch: ${security_patch:-Unknown}"$'\n'
  echo " Kernel: ${kernel:-Unknown}"
  report+=" Kernel: ${kernel:-Unknown}"$'\n'
  echo " Arch: ${arch:-Unknown}"
  report+=" Arch: ${arch:-Unknown}"$'\n'
  echo " Supported Archs: ${arch_list:-Unknown}"
  report+=" Supported Archs: ${arch_list:-Unknown}"$'\n'
  echo " Root: $rooted"
  report+=" Root: $rooted"$'\n'
  echo
  report+=$'\n'
  # === Uptime ===
  echo -e "${GREEN}Uptime${NC}"
  report+="Uptime"$'\n'
  # Get uptime in seconds from /proc/uptime.
  local uptime_seconds=$(adb shell cat /proc/uptime 2>/dev/null | awk '{print int($1)}' | tr -d '\r')
  if [[ -z "$uptime_seconds" ]]; then
    echo " Failed to retrieve uptime"
  report+=" Failed to retrieve uptime"$'\n'
  else
    # Convert to hours:minutes.
    local hours=$((uptime_seconds / 3600))
    local minutes=$(( (uptime_seconds % 3600) / 60 ))
    local up_time=$(printf "%d:%02d" $hours $minutes)
    echo " ${up_time}"
    report+=" ${up_time}"$'\n'
  fi
  echo
  report+=$'\n'
  # === Storage ===
  echo -e "${GREEN}Storage Usage${NC}"
  report+="Storage Usage"$'\n'
  local storage=""
  if [[ "$rooted" == "Yes" ]]; then
    storage=$(adb shell df -h / /storage/emulated 2>/dev/null | tr -d '\r')
  else
    storage=$(adb shell df -h /storage/emulated/0 2>/dev/null | tr -d '\r')
  fi
  if [[ -n "$storage" ]]; then
    # Save all lines properly without subshell
    while IFS= read -r line || [[ -n "$line" ]]; do
      echo " $line"
      report+=" $line"$'\n'
    done <<< "$storage"
  else
    echo " Failed to retrieve storage info"
    report+=" Failed to retrieve storage info"$'\n'
  fi
  echo
  report+=$'\n'
  # === Memory ===
  echo -e "${GREEN}Memory Info${NC}"
  report+="Memory Info"$'\n'
  # Get memory info from free -h.
  local mem=$(adb shell free -h 2>/dev/null | grep Mem)
  if [[ -n "$mem" ]]; then
    # Parse and display memory stats.
    local total=$(echo "$mem" | awk '{print $2}')
    local used=$(echo "$mem" | awk '{print $3}')
    local free=$(echo "$mem" | awk '{print $4}')
    local shared=$(echo "$mem" | awk '{print $5}')
    local buff_cache=$(echo "$mem" | awk '{print $6}')
    echo " total=${total} used=${used} free=${free} shared=${shared} buffer/cache=${buff_cache}"
    report+=" total=${total} used=${used} free=${free} shared=${shared} buffer/cache=${buff_cache}"$'\n'
  else
    echo " Failed to retrieve memory info"
    report+=" Failed to retrieve memory info"$'\n'
  fi
  echo
  report+=$'\n'
  # === Screen ===
  echo -e "${GREEN}Screen Info${NC}"
  report+="Screen Info"$'\n'
  # Get screen resolution from wm size.
  local resolution=$(adb shell wm size 2>/dev/null | grep "Physical size" | cut -d: -f2 | xargs)
  echo " Resolution: ${resolution:-Unknown}"
  report+=" Resolution: ${resolution:-Unknown}"$'\n'
  echo
  report+=$'\n'
  # === Network ===
  echo -e "${GREEN}Network Info${NC}"
  report+="Network Info"$'\n'
  # Dump netstats.
  local netstats=$(adb shell dumpsys netstats 2>/dev/null)
  if [[ -z "$netstats" ]]; then
    echo " Failed to retrieve network info"
    report+=" Failed to retrieve network info"$'\n'
  else
    # Extract WiFi SSID from wlan0 line.
    local ssid_line=$(echo "$netstats" | grep -E 'iface=wlan0' | head -n 1)
    local wifi_name=$(echo "$ssid_line" | grep -oP 'wifiNetworkKey="([^"]+)"' | cut -d'"' -f2)
    if [[ -z "$wifi_name" ]]; then
      wifi_name="Not connected"
    fi
    # Get IP from wlan0 or eth0.
    local ip_address=$(adb shell ip -f inet addr show wlan0 2>/dev/null | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | tr -d '\r')
    if [[ -z "$ip_address" ]]; then
      ip_address=$(adb shell ip -f inet addr show eth0 2>/dev/null | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | tr -d '\r')
    fi
    if [[ -z "$ip_address" ]]; then
      ip_address="Not connected"
    fi
    # Display network info.
    echo " WiFi Name: ${wifi_name}"
    report+=" WiFi Name: ${wifi_name}"$'\n'
    echo " IP Address: ${ip_address}"
    report+=" IP Address: ${ip_address}"$'\n'
  fi
  echo
  report+=$'\n'
  # === Hardware ===
  echo -e "${GREEN}Hardware Info${NC}"
  report+="Hardware Info"$'\n'
  # Get CPU info from /proc/cpuinfo.
  local cpu_info=$(adb shell cat /proc/cpuinfo 2>/dev/null)
  local hardware=$(echo "$cpu_info" | grep 'Hardware' | head -n1 | cut -d: -f2 | xargs)
  if [[ -z "$hardware" ]]; then
    hardware=$(adb shell getprop ro.hardware 2>/dev/null | tr -d '\r' | xargs)
  fi
  local processor=$(echo "$cpu_info" | grep 'Processor' | head -n1 | cut -d: -f2 | xargs)
  local cores=$(echo "$cpu_info" | grep -c '^processor')
  [[ $cores -eq 0 ]] && cores="Unknown"
  local cpu="${processor:-${hardware:-Unknown}} (${cores} cores)"
  # Get GPU info from dumpsys SurfaceFlinger.
  local gpu_info=$(adb shell dumpsys SurfaceFlinger 2>/dev/null | grep 'GLES: ' | head -n1)
  local renderer=$(echo "$gpu_info" | cut -d ':' -f2- | cut -d ',' -f1 | xargs)
  local version=$(echo "$gpu_info" | cut -d ',' -f2 | xargs)
  local gpu="${renderer:-Unknown}"
  if [[ -n "$version" ]]; then
    gpu="$gpu (${version})"
  fi
  if [[ -z "$renderer" ]]; then
    # Fallback to OpenGL ES version.
    local opengles_version=$(adb shell getprop ro.opengles.version 2>/dev/null | tr -d '\r' | xargs)
    if [[ "$opengles_version" =~ ^[0-9]+$ ]]; then
      local major=$((opengles_version >> 16))
      local minor=$((opengles_version & 0xFFFF))
      gpu="OpenGL ES ${major}.${minor}"
    else
      gpu="Unknown"
    fi
  fi
  # Display hardware info.
  echo " CPU: $cpu"
  report+=" CPU: $cpu"$'\n'
  echo " GPU: $gpu"
  report+=" GPU: $gpu"$'\n'
  echo
  report+=$'\n'
  while true; do
    read -r -p "Do you want to save the report? (y/n) " choice
    case "$choice" in
      y|Y )
        read -r -p "Enter custom path (leave empty for script directory): " custom_path
        # Automatically remove leading and trailing single quotes if present
        custom_path=${custom_path#\'}
        custom_path=${custom_path%\'}
        if [[ -z "$custom_path" ]]; then
          custom_path="$SCRIPT_DIR"
        fi
        read -r -p "Enter custom name: " custom_name
        local filename="DroidSuiteDeviceReport_${custom_name}.txt"
        echo "$report" > "$custom_path/$filename"
        echo "Device Report saved successfully to $custom_path/$filename."
        echo "Press enter to return"
        read -r
        break
        ;;
      n|N )
        echo "Device report not saved. Press enter to return"
        read -r
        break
        ;;
      * )
        echo "Invalid choice. Please enter y or n."
        ;;
    esac
  done
}

# =============================================================================
# APP MANAGEMENT FUNCTIONS
# =============================================================================

# Install apps
# Installs single APK or all APKs from a folder, with timeout and version checks.
install_apps() {
  local modified_count=0
  # Get path(s) to APK(s) or folder(s).
  read -r -p "Path to APK or folder (space-separated for multiple): " path
  # Check for invalid characters in the entire input before parsing.
  if echo "$path" | grep -q '[[:cntrl:]*?\[\]{}~|;&'"'"'"`$;]'; then
    echo -e "${RED}Input contains invalid characters (*, ?, [, ], {, }, ~, |, ;, &, ', \" , \`, $, or control characters).${NC}"
    return 1
  fi
  # Parse into paths array using eval to handle quoted paths with spaces.
  local paths
  eval "paths=($path)" 2>/dev/null || {
    echo -e "${RED}Error parsing paths.${NC}"
    return 1
  }
  # Ensure device connected.
  check_device_connection || return 1
  # Check SDK for install compatibility warnings.
  local sdk=$(adb shell getprop ro.build.version.sdk 2>/dev/null | tr -d '\r' | xargs)
  if [[ "$sdk" -ge 36 ]]; then
    echo -e "${YELLOW}Note: On Android 16+, apps targeting SDK <25 may not install.${NC}"
  elif [[ "$sdk" -ge 35 ]]; then
    echo -e "${YELLOW}Note: On Android 15, apps targeting SDK <24 may not install.${NC}"
  fi
  # Process each path.
  for p in "${paths[@]}"; do
    # Check for invalid characters in this specific path.
    if echo "$p" | grep -q '[[:cntrl:]*?\[\]{}~|;&'"'"'"`$;]'; then
      echo -e "${RED}Path contains invalid characters: $p${NC}"
      continue
    fi
    if [[ -f "$p" ]]; then
      # Single file: Check extension and install with timeout.
      if [[ ! "$p" == *.apk ]]; then
        echo -e "${YELLOW}Warning: File does not end with .apk extension.${NC}"
      fi
      echo -e "${GREEN}Installing $p...${NC}"
      timeout 300 adb install "$p" || {
        echo -e "${RED}Failed to install $p${NC}"
        continue
      }
      echo -e "${GREEN}Successfully installed $p${NC}"
      ((modified_count++))
    elif [[ -d "$p" ]]; then
      # Folder: Find all APKs and install each.
      mapfile -d '' -t files < <(find "$p" -maxdepth 1 -name '*.apk' -type f -print0)
      if [[ ${#files[@]} -eq 0 ]]; then
        echo -e "${RED}No APK files found in $p${NC}"
        continue
      fi
      for f in "${files[@]}"; do
        echo -e "${GREEN}Installing $f...${NC}"
        timeout 300 adb install "$f" || { echo -e "${RED}Failed to install $f${NC}"; continue; }
        echo -e "${GREEN}Successfully installed $f${NC}"
        ((modified_count++))
      done
    else
      echo -e "${RED}Not a valid file or folder: $p${NC}"
      continue
    fi
  done
  # Only prompt to return if any installations were attempted (successful or not).
  if [[ ${#paths[@]} -gt 0 ]]; then
    read -r -p "Press Enter to return..."
  fi
}

# Uninstall apps
# Lists packages, allows selection, clears data/cache, and uninstalls (with root option for global).
uninstall_apps() {
  # Ensure device connected.
  check_device_connection || return 1
  local use_root=false
  # Check for root and prompt for use.
  if is_rooted; then
    read -r -p "Device is rooted. Use root privileges for global operation? (y/n): " choice
    if [[ "$choice" == "y" || "$choice" == "Y" ]]; then
      use_root=true
    fi
  fi
  # Get all packages.
  local all_packages=()
  while IFS= read -r line; do all_packages+=("$line"); done < <(adb shell pm list packages | sed 's/package://g' | tr -d '\r')
  if [[ ${#all_packages[@]} -eq 0 ]]; then
    echo -e "${RED}Failed to list packages${NC}"
    return 1
  fi
  # Get disabled packages.
  local disabled=$(adb shell pm list packages -d | sed 's/package://g' | tr -d '\r' || echo "")
  # Display enabled packages.
  echo -e "${GREEN}Enabled:${NC}"
  for pkg in "${all_packages[@]}"; do
    if ! echo "$disabled" | grep -q "^$pkg$"; then
      echo " $pkg"
    fi
  done
  # Display disabled packages.
  echo -e "${GREEN}Disabled:${NC}"
  for pkg in "${all_packages[@]}"; do
    if echo "$disabled" | grep -q "^$pkg$"; then
      echo " $pkg"
    fi
  done
  # Get user input for packages to uninstall.
  read -r -p "Enter package name(s) to uninstall (space separated for multiple): " sel
  if [[ -z "$sel" ]]; then
    echo -e "${GREEN}No selection made.${NC}"
    return 0
  fi
  local selected=()
  # Validate selected packages.
  for pkg in $sel; do
    if printf '%s\n' "${all_packages[@]}" | grep -q "^$pkg$"; then
      selected+=("$pkg")
    else
      echo -e "${YELLOW}Invalid package: $pkg (skipping)${NC}"
    fi
  done
  if [[ ${#selected[@]} -eq 0 ]]; then
    echo -e "${RED}No valid selections.${NC}"
    return 1
  fi
  # Confirm selection.
  echo -e "${YELLOW}Selected package(s) to uninstall:${NC}"
  for pkg in "${selected[@]}"; do
    echo " $pkg"
  done
  read -r -p "Confirm uninstallation of these ${#selected[@]} package(s)? (y/N): " confirm
  if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
    echo -e "${GREEN}Uninstallation canceled.${NC}"
    return 0
  fi
  local success_count=0
  for pkg in "${selected[@]}"; do
    # Clear data before uninstall.
    if $use_root; then
      adb shell su -c "pm clear \"$pkg\"" && echo -e "${GREEN}Cleared data for $pkg${NC}" || echo -e "${YELLOW}Failed to clear data for $pkg (continuing)${NC}"
    else
      adb shell pm clear --user 0 "$pkg" && echo -e "${GREEN}Cleared data for $pkg${NC}" || echo -e "${YELLOW}Failed to clear data for $pkg (continuing)${NC}"
    fi
    # Uninstall.
    if $use_root; then
      adb shell su -c "pm uninstall \"$pkg\""
    else
      adb shell pm uninstall --user 0 "$pkg"
    fi
    # Verify uninstall.
    local check_cmd="adb shell pm list packages"
    if ! $use_root; then
      check_cmd="$check_cmd --user 0"
    fi
    if eval "$check_cmd | grep -q \"^package:$pkg$\""; then
      echo -e "${RED}Failed to uninstall $pkg (package is still installed)${NC}"
    else
      if $use_root; then
        echo -e "${GREEN}Globally uninstalled $pkg${NC}"
      else
        echo -e "${GREEN}Uninstalled $pkg for current user.${NC}"
      fi
      ((success_count++))
    fi
  done
  echo -e "${GREEN}Successfully processed $success_count package(s).${NC}"
  read -r -p "Press Enter to return..."
}

# Enable/disable apps
# Lists packages, allows selection, and enables/disables (with root for global).
enable_disable_app() {
  # Ensure device connected.
  check_device_connection || return 1
  local use_root=false
  # Check for root and prompt.
  if is_rooted; then
    read -r -p "Device is rooted. Use root privileges for global operation? (y/n): " choice
    if [[ "$choice" == "y" || "$choice" == "Y" ]]; then
      use_root=true
    fi
  fi
  # Get all packages.
  local all_packages=()
  while IFS= read -r line; do all_packages+=("$line"); done < <(adb shell pm list packages | sed 's/package://g' | tr -d '\r')
  if [[ ${#all_packages[@]} -eq 0 ]]; then
    echo -e "${RED}Failed to list packages${NC}"
    return 1
  fi
  # Get disabled packages.
  local disabled=$(adb shell pm list packages -d | sed 's/package://g' | tr -d '\r' || echo "")
  # Display enabled.
  echo -e "${GREEN}Enabled:${NC}"
  for pkg in "${all_packages[@]}"; do
    if ! echo "$disabled" | grep -q "^$pkg$"; then
      echo " $pkg"
    fi
  done
  # Display disabled.
  echo -e "${GREEN}Disabled:${NC}"
  for pkg in "${all_packages[@]}"; do
    if echo "$disabled" | grep -q "^$pkg$"; then
      echo " $pkg"
    fi
  done
  # Get selection.
  read -r -p "Enter exact package names to modify (space separated for multiple): " sel
  if [[ -z "$sel" ]]; then
    echo -e "${GREEN}No selection made.${NC}"
    return 0
  fi
  local selected=()
  # Validate.
  for name in $sel; do
    if printf '%s\n' "${all_packages[@]}" | grep -q "^$name$"; then
      selected+=("$name")
    else
      echo -e "${YELLOW}Invalid package: $name (skipping)${NC}"
    fi
  done
  if [[ ${#selected[@]} -eq 0 ]]; then
    echo -e "${RED}No valid selections.${NC}"
    return 1
  fi
  # Display selected.
  echo -e "${YELLOW}Selected packages:${NC}"
  for pkg in "${selected[@]}"; do
    echo " $pkg"
  done
  # Choose action.
  echo -e "1) Enable\n2) Disable"
  read -r -p "Choice for all selected: " action
  local modified_count=0
  case $action in
    1)
      # Enable each.
      for pkg in "${selected[@]}"; do
        if $use_root; then
          adb shell su -c "pm enable \"$pkg\"" || {
            echo -e "${RED}Failed to enable $pkg${NC}"
            continue
          }
        else
          adb shell pm enable --user 0 "$pkg" || {
            echo -e "${RED}Failed to enable $pkg (may require root or system-level access)${NC}"
            continue
          }
        fi
        # Verify.
        if adb shell pm list packages -e | grep -q "^package:$pkg$"; then
          echo -e "${GREEN}Successfully enabled $pkg${NC}"
          ((modified_count++))
        else
          echo -e "${RED}Failed to enable $pkg (still appears disabled)${NC}"
        fi
      done
      ;;
    2)
      # Disable each.
      for pkg in "${selected[@]}"; do
        if $use_root; then
          adb shell su -c "pm disable \"$pkg\"" || {
            echo -e "${RED}Failed to disable $pkg${NC}"
            continue
          }
        else
          adb shell pm disable-user --user 0 "$pkg" || {
            echo -e "${RED}Failed to disable $pkg${NC}"
            continue
          }
        fi
        # Verify.
        if adb shell pm list packages -d | grep -q "^package:$pkg$"; then
          echo -e "${GREEN}Successfully disabled $pkg${NC}"
          ((modified_count++))
        else
          echo -e "${RED}Failed to disable $pkg (still appears enabled)${NC}"
        fi
      done
      ;;
    *)
      echo -e "${RED}Invalid choice.${NC}"
      return 1
      ;;
  esac
  echo -e "${GREEN}Modified $modified_count package(s).${NC}"
  read -r -p "Press Enter to return..."
}

# Delete app data and cache
# Lists packages, allows selection, clears data/cache (with root for global).
delete_app_data_cache() {
  # Ensure device connected.
  check_device_connection || return 1
  local use_root=false
  local root_detected=false
  # Check for root.
  if adb shell "su -c 'echo rooted'" 2>/dev/null | grep -q 'rooted'; then
    root_detected=true
  fi
  if $root_detected; then
    while true; do
      read -r -p "Device is rooted. Use root privileges for global operation? (y/N): " choice
      if [[ "$choice" =~ ^[Yy]$ ]]; then
        use_root=true
        break
      elif [[ "$choice" =~ ^[Nn]$ || -z "$choice" ]]; then
        use_root=false
        break
      else
        echo "Invalid input. Please enter y or n."
      fi
    done
  fi
  # Display enabled packages.
  echo -e "${GREEN}Enabled packages:${NC}"
  adb shell pm list packages -e | sed 's/package://g' | tr -d '\r' | sort || {
    echo -e "${RED}Failed to list enabled packages${NC}"
    return 1
  }
  # Display disabled packages.
  echo -e "${GREEN}Disabled packages:${NC}"
  adb shell pm list packages -d | sed 's/package://g' | tr -d '\r' | sort || {
    echo -e "${RED}Failed to list disabled packages${NC}"
    return 1
  }
  # Get selection.
  read -r -p "Enter package names to delete data and cache (space separated for multiple): " input
  if [[ -z "$input" ]]; then
    echo -e "${GREEN}No packages entered. Operation canceled.${NC}"
    return 0
  fi
  IFS=' ' read -r -a selected <<< "$input"
  if [[ ${#selected[@]} -eq 0 ]]; then
    echo -e "${RED}No valid selections.${NC}"
    return 1
  fi
  # Confirm.
  echo -e "${YELLOW}Selected packages to delete data/cache:${NC}"
  for pkg in "${selected[@]}"; do
    echo " $pkg"
  done
  while true; do
    read -r -p "This will delete ALL data and cache for these ${#selected[@]} packages (user 0). Confirm? (y/N): " confirm
    if [[ "$confirm" =~ ^[Yy]$ ]]; then
      break
    elif [[ "$confirm" =~ ^[Nn]$ || -z "$confirm" ]]; then
      echo -e "${GREEN}Operation canceled.${NC}"
      return 0
    else
      echo "Invalid input. Please enter y or n."
    fi
  done
  local cleared_count=0
  for pkg in "${selected[@]}"; do
    if $use_root; then
      # Root clear: Use pm clear or rm.
      if adb shell su -c "pm clear \"$pkg\"" &>/dev/null || adb shell su -c "rm -rf /data/data/\"$pkg\"/*" &>/dev/null; then
        ((cleared_count++))
        echo -e "${GREEN}Data and cache globally deleted for $pkg.${NC}"
      else
        echo -e "${RED}Failed to clear data for $pkg.${NC}"
      fi
    else
      # Non-root: Use pm clear, fallback to cache rm.
      if adb shell pm clear --user 0 "$pkg" &>/dev/null; then
        ((cleared_count++))
        echo -e "${GREEN}Data and cache deleted for $pkg (user 0).${NC}"
      else
        echo -e "${RED}Failed to clear data for $pkg (permission/user issue or command not supported)${NC}"
        if adb shell "rm -rf /data/data/$pkg/cache/*" &>/dev/null; then
          echo -e "${YELLOW}Fallback: Only cache cleared for $pkg.${NC}"
          ((cleared_count++))
        else
          echo -e "${RED}Failed to clear cache as fallback for $pkg.${NC}"
        fi
      fi
    fi
  done
  echo -e "${GREEN}Cleared $cleared_count package(s).${NC}"
  read -r -p "Press Enter to return..."
}

# Clear cache (all-in-one)
# Clears system cache, with root option for more thorough clear.
cache_clear() {
    while true; do
        read -p "Are you sure you want to clean the cache for all apps? (y/n): " confirm
        if [[ -z "$confirm" ]]; then
            continue
        elif [[ "$confirm" == "y" || "$confirm" == "Y" ]]; then
            break
        elif [[ "$confirm" == "n" || "$confirm" == "N" ]]; then
            return
        else
            echo "Invalid input. Please enter y or n."
        fi
    done

    # Check for root.
    if adb shell su -c id &>/dev/null; then
        echo "Root access detected."
        read -p "Do you want to use root for cache clearing? (y/n): " use_root
        if [[ "$use_root" == "y" || "$use_root" == "Y" ]]; then
            # Root: rm cache directories.
            if adb shell su -c "rm -rf /data/cache/* /data/dalvik-cache/*" &>/dev/null; then
                echo "Done"
            else
                echo "Failed"
            fi
        else
            # Non-root: Use pm trim-caches.
            if adb shell pm trim-caches 999G &>/dev/null; then
                echo "Done"
            else
                echo "Failed"
            fi
        fi
    else
        # No root: Use pm trim-caches.
        if adb shell pm trim-caches 999G &>/dev/null; then
            echo "Done"
        else
            echo "Failed"
        fi
    fi
    read -p "Press Enter to return"
}

# =============================================================================
# FILE MANAGEMENT FUNCTIONS
# =============================================================================

# Pull file from device
# Searches for files (with root option), allows selection, pulls to local dir.
pull_file() {
  local SCRIPT_DIR=$(dirname "$(realpath "$0")")
  # Ensure device connected.
  check_device_connection || return 1
  local use_root=false
  local search_paths="/storage/emulated/0/"
  local search_desc="In: /storage/emulated/0/"
  # Prompt for root search.
  if is_rooted; then
    read -r -p "Device is rooted. Search with root privileges (entire device)? (y/n): " choice
    if [[ "$choice" == "y" || "$choice" == "Y" ]]; then
      use_root=true
      search_paths="/"
      search_desc="In: entire device (using root privileges)"
    fi
  fi
  # Get filename pattern.
  read -r -p "Enter filename to search (use * for wildcard, e.g. '*.txt'): " fname
  if [[ -z "$fname" ]]; then
    echo -e "${RED}No filename provided.${NC}"
  read -r -p "press enter to return"
    return 1
  fi
  if [[ ! "$fname" == *'*'* ]]; then
    fname="*${fname}*"
  fi
  fname_escaped=$(printf '%s' "$fname" | sed "s/'/'\\''/g")
  echo -e "${GREEN}Searching for files matching: $fname${NC}"
  echo -e "${GREEN}$search_desc${NC}"
  local results=()
  # Search with find, using root if selected.
  if $use_root; then
    while IFS= read -r line; do results+=("$line"); done < <(adb shell "su -c \"find $search_paths -iname '$fname_escaped' -type f 2>/dev/null\"" | tr -d '\r')
  else
    while IFS= read -r line; do results+=("$line"); done < <(adb shell "for path in $search_paths; do if [ -d \"\$path\" ]; then find \"\$path\" -iname '$fname_escaped' -type f 2>/dev/null; fi; done" | tr -d '\r')
  fi
  if [[ ${#results[@]} -eq 0 ]]; then
    echo -e "${YELLOW}file cant be found press enter to return${NC}"
    read -r -p ""
    return 1
  fi
  # Display results.
  echo -e "${GREEN}Found ${#results[@]} file(s):${NC}"
  for i in "${!results[@]}"; do
    echo "$((i+1))) ${results[i]}"
  done
  # Get selection.
  read -r -p "Select numbers to pull (space separated, or 'all'): " sel
  if [[ -z "$sel" ]]; then
    echo -e "${GREEN}No selection made.${NC}"
  read -r -p "press enter to return"
    return 0
  fi
  local selected=()
  if [[ "$sel" == "all" ]]; then
    selected=("${results[@]}")
  else
    for num in $sel; do
      if [[ $num =~ ^[0-9]+$ ]] && (( num >= 1 && num <= ${#results[@]} )); then
        selected+=("${results[$((num-1))]}")
      else
        echo -e "${YELLOW}Invalid number: $num (skipping)${NC}"
  read -r -p "press enter to return"
      fi
    done
  fi
  if [[ ${#selected[@]} -eq 0 ]]; then
    echo -e "${RED}No valid selections.${NC}"
  read -r -p "press enter to return"
    return 1
  fi
  # Get destination.
  read -r -p "Local destination directory (default: script's directory): " dst
  # Remove surrounding single quotes if present (from drag-and-drop).
  if [[ "${dst:0:1}" == "'" && "${dst: -1}" == "'" ]]; then
    dst="${dst:1:-1}"
  fi
  dst="${dst:-$SCRIPT_DIR}"
  if [[ ! -d "$dst" ]]; then
    echo -e "${RED}Destination is not a directory: $dst${NC}"
    return 1
  fi
  local pulled_count=0
  for path in "${selected[@]}"; do
    local base=$(basename "$path")
    local local_path="$dst/$base"
    echo -e "${GREEN}Pulling $path to $local_path...${NC}"
    if $use_root; then
      # Root pull: Cat file with su.
      adb shell "su -c 'cat \"$path\" 2>/dev/null'" > "$local_path"
      if [[ $? -eq 0 && -s "$local_path" ]]; then
        ((pulled_count++))
        if [[ -f "$local_path" && -s "$local_path" ]]; then
          echo -e "${GREEN}Successfully pulled $path and verified it exists locally.${NC}"
        else
          echo -e "${RED}Pulled $path but verification failed.${NC}"
        fi
      else
        echo -e "${RED}Failed to pull $path${NC}"
        rm -f "$local_path"
      fi
    else
      # Normal pull with timeout.
      if timeout 300 adb pull "$path" "$local_path" >/dev/null 2>&1; then
        ((pulled_count++))
        if [[ -f "$local_path" && -s "$local_path" ]]; then
          echo -e "${GREEN}Successfully pulled $path and verified it exists locally.${NC}"
        else
          echo -e "${RED}Pulled $path but verification failed.${NC}"
        fi
      else
        echo -e "${RED}Failed to pull $path${NC}"
      fi
    fi
  done
  echo -e "${GREEN}Pulled $pulled_count file(s) successfully.${NC}"
  read -r -p "Press Enter to return..."
}

# Push file to device
# Pushes local files to device (with root for restricted areas).
push_file() {
  # Ensure device connected.
  check_device_connection || return 1

  local use_root=false
  # Prompt for root.
  if is_rooted; then
    read -r -p "Device is rooted. Use root privileges to push (allows restricted areas)? (y/n): " choice
    if [[ "$choice" == "y" || "$choice" == "Y" ]]; then
      use_root=true
    fi
  fi

  # Get source paths.
  read -r -p "Local file paths (space-separated, quote paths with spaces): " src
  if [[ -z "$src" ]]; then
    return 1
  fi

  # Parse using eval for quoted paths.
  local files=()
  if ! eval "files=($src)" 2>/dev/null; then
    echo -e "${RED}Error parsing file paths.${NC}"
  read -r -p "press enter to return"
    return 1
  fi
  if [ ${#files[@]} -eq 0 ]; then
    echo -e "${RED}No valid file paths provided.${NC}"
  read -r -p "press enter to return"
    return 1
  fi

  # Validate files.
  local valid_files=()
  for file in "${files[@]}"; do
    if [[ -f "$file" ]]; then
      valid_files+=("$file")
    else
      echo -e "${RED}Local file not found: $file${NC}"
  read -r -p "press enter to return"
    fi
  done
  if [ ${#valid_files[@]} -eq 0 ]; then
    return 1
  fi
  files=("${valid_files[@]}")

  # Get destination.
  read -r -p "Remote destination (default: /storage/emulated/0/Download/): " dst

  if [[ -z "$dst" ]]; then
    dst="/storage/emulated/0/Download/"
  fi

  # Ensure dir for multiple files.
  if [ ${#files[@]} -gt 1 ] && [[ ! "$dst" =~ /$ ]]; then
    dst="${dst}/"
    echo -e "${YELLOW}Appended / to destination for multiple files.${NC}"
  fi

  # Validate destination path.
  if [[ ! "$dst" =~ ^/[a-zA-Z0-9_/.~-]+/?$ ]]; then
    echo -e "${RED}Invalid remote destination.${NC}"
  read -r -p "press enter to return"
    return 1
  fi

  # Warn about /sdcard symlink.
  if [[ "$dst" == "/sdcard/"* ]]; then
    echo -e "${YELLOW}Note: /sdcard is a symlink. Using /storage/emulated/0/ is more reliable.${NC}"
  fi

  echo -e "${GREEN}Pushing ${#files[@]} files to $dst...${NC}"
  local all_success=true
  local i=0
  for file in "${files[@]}"; do
    i=$((i + 1))
    local basename_file=$(basename "$file")
    local remote_path="$dst"
    if [[ "$dst" =~ /$ ]] || [ ${#files[@]} -gt 1 ]; then
      remote_path="${dst}${basename_file}"
    fi

    echo -e "${GREEN}Pushing $file -> $remote_path...${NC}"
    local push_success=false
    if $use_root; then
      # Root push: Use temp file and cp.
      local temp_path="/data/local/tmp/push_$$_${i}_${basename_file}"
      if adb push "$file" "$temp_path" && adb shell su -c "cp -f \"$temp_path\" \"$remote_path\"" && adb shell su -c "rm -f \"$temp_path\""; then
        push_success=true
      else
        echo -e "${RED}Failed to push $file using root${NC}"
        adb shell su -c "rm -f \"$temp_path\"" &>/dev/null
        all_success=false
      fi
    else
      # Normal push with timeout.
      if timeout 300 adb push "$file" "$remote_path"; then
        push_success=true
      else
        echo -e "${RED}Failed to push $file${NC}"
        all_success=false
      fi
    fi

    if $push_success; then
      echo -e "${GREEN}Verifying file presence on device...${NC}"

      local file_exists=false
      if $use_root; then
        if adb shell su -c "[ -f \"$remote_path\" ]"; then
          file_exists=true
        fi
      else
        if adb shell "[ -f \"$remote_path\" ]"; then
          file_exists=true
        fi
      fi

      if $file_exists; then
        echo -e "${GREEN}File confirmed on device at: $remote_path${NC}"
      else
        echo -e "${RED}File not found on device at: $remote_path (push may have failed silently or permissions issue)${NC}"
        all_success=false
      fi
    fi
  done

  if ! $all_success; then
    return 1
  fi

  read -r -p "Press Enter to return..."
}

# Delete file from device
# Searches for files, allows selection, deletes with verification.
delete_file() {
  # Helper to escape single quotes.
  escape_single() {
    printf '%s' "$1" | sed "s/'/'\\''/g"
  }

  # Ensure device connected.
  check_device_connection || return 1

  local use_root=false
  local search_paths="/storage/emulated/0/"
  local search_desc="In: /storage/emulated/0/"

  # Prompt for root.
  if is_rooted; then
    read -r -p "Device is rooted. Search with root privileges (entire device)? (y/n): " choice
    if [[ "$choice" == "y" || "$choice" == "Y" ]]; then
      use_root=true
      search_paths="/"
      search_desc="In: entire device (using root privileges)"
    fi
  fi

  # Get filename pattern.
  read -r -p "Enter filename to search (use * for wildcard, e.g. '*.txt'): " fname
  if [[ -z "$fname" ]]; then
    echo -e "${RED}No filename provided.${NC}"
    return 1
  fi
  if [[ ! "$fname" == *'*'* ]]; then
    fname="*${fname}*"
  fi
  fname_escaped=$(escape_single "$fname")

  echo -e "${GREEN}Searching for files matching: $fname${NC}"
  echo -e "${GREEN}$search_desc${NC}"
  local results=()
  # Search.
  if $use_root; then
    while IFS= read -r line; do results+=("$line"); done < <(adb shell "su -c \"find $search_paths -iname '$fname_escaped' -type f 2>/dev/null\"" | tr -d '\r')
  else
    while IFS= read -r line; do results+=("$line"); done < <(adb shell "for path in $search_paths; do if [ -d \"\$path\" ]; then find \"\$path\" -iname '$fname_escaped' -type f 2>/dev/null; fi; done" | tr -d '\r')
  fi
  if [[ ${#results[@]} -eq 0 ]]; then
    echo -e "${YELLOW}File couldn't be found.${NC}"
    read -r -p "Press Enter to continue..."
    return 1
  fi
  # Display.
  echo -e "${GREEN}Found ${#results[@]} file(s):${NC}"
  for i in "${!results[@]}"; do
    echo "$((i+1))) ${results[i]}"
  done
  # Get selection.
  read -r -p "Select numbers to delete (space separated, or 'all'): " sel
  if [[ -z "$sel" ]]; then
    echo -e "${GREEN}No selection made.${NC}"
    return 0
  fi
  local selected=()
  if [[ "$sel" == "all" ]]; then
    selected=("${results[@]}")
  else
    for num in $sel; do
      if [[ $num =~ ^[0-9]+$ ]] && (( num >= 1 && num <= ${#results[@]} )); then
        selected+=("${results[$((num-1))]}")
      else
        echo -e "${YELLOW}Invalid number: $num (skipping)${NC}"
      fi
    done
  fi
  if [[ ${#selected[@]} -eq 0 ]]; then
    echo -e "${RED}No valid selections.${NC}"
    return 1
  fi
  # Confirm.
  echo -e "${YELLOW}Selected files to delete:${NC}"
  for path in "${selected[@]}"; do
    echo "  $path"
  done
  read -r -p "Confirm deletion of these ${#selected[@]} files? (y/N): " confirm
  if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
    echo -e "${GREEN}Deletion canceled.${NC}"
    return 0
  fi
  local deleted_count=0
  for path in "${selected[@]}"; do
    local path_escaped=$(escape_single "$path")
    echo -e "${GREEN}Deleting $path...${NC}"
    local delete_cmd="rm -f '${path_escaped}' 2>/dev/null"
    if $use_root; then
      delete_cmd="su -c \"$delete_cmd\""
    fi
    adb shell "$delete_cmd"
    # Verify deletion.
    local check_cmd="[ -f '${path_escaped}' ] && echo 'exists' || echo 'deleted'"
    if $use_root; then
      check_cmd="su -c \"$check_cmd\""
    fi
    local status=$(adb shell "$check_cmd" | tr -d '\r')
    if [[ "$status" == "deleted" ]]; then
      ((deleted_count++))
      echo -e "${GREEN}Successfully deleted $path${NC}"
    else
      echo -e "${RED}Failed to delete $path${NC}"
    fi
  done
  echo -e "${GREEN}Deleted $deleted_count file(s) successfully.${NC}"
  read -r -p "Press Enter to return..."
}

# Pull folder from device
# Similar to pull_file, but for folders using tar for root or adb pull.
pull_folder() {
  local SCRIPT_DIR=$(dirname "$(realpath "$0")")
  # Ensure device connected.
  check_device_connection || return 1
  local use_root=false
  local search_paths="/storage/emulated/0/"
  local search_desc="In: /storage/emulated/0/"
  # Prompt for root.
  if is_rooted; then
    read -r -p "Device is rooted. Search with root privileges (entire device)? (y/n): " choice
    if [[ "$choice" == "y" || "$choice" == "Y" ]]; then
      use_root=true
      search_paths="/"
      search_desc="In: entire device (using root privileges)"
    fi
  fi
  # Get folder pattern.
  read -r -p "Enter folder name to search (use * for wildcard, e.g. '*Music*'): " fname
  if [[ -z "$fname" ]]; then
    echo -e "${RED}No folder name provided.${NC}"
  read -r -p "press enter to return"
    return 1
  fi
  if [[ ! "$fname" == *'*'* ]]; then
    fname="*${fname}*"
  fi
  fname_escaped=$(printf '%s' "$fname" | sed "s/'/'\\''/g")
  echo -e "${GREEN}Searching for folders matching: $fname${NC}"
  echo -e "${GREEN}$search_desc${NC}"
  local results=()
  # Search for directories.
  if $use_root; then
    while IFS= read -r line; do results+=("$line"); done < <(adb shell "su -c \"find $search_paths -iname '$fname_escaped' -type d 2>/dev/null\"" | tr -d '\r')
  else
    while IFS= read -r line; do results+=("$line"); done < <(adb shell "for path in $search_paths; do if [ -d \"\$path\" ]; then find \"\$path\" -iname '$fname_escaped' -type d 2>/dev/null; fi; done" | tr -d '\r')
  fi
  if [[ ${#results[@]} -eq 0 ]]; then
    echo -e "${YELLOW}folder cant be found press enter to return${NC}"
    read -r -p ""
    return 1
  fi
  # Display.
  echo -e "${GREEN}Found ${#results[@]} folder(s):${NC}"
  for i in "${!results[@]}"; do
    echo "$((i+1))) ${results[i]}"
  done
  # Get selection.
  read -r -p "Select numbers to pull (space separated, or 'all'): " sel
  if [[ -z "$sel" ]]; then
    echo -e "${GREEN}No selection made.${NC}"
  read -r -p "press enter to return"
    return 0
  fi
  local selected=()
  if [[ "$sel" == "all" ]]; then
    selected=("${results[@]}")
  else
    for num in $sel; do
      if [[ $num =~ ^[0-9]+$ ]] && (( num >= 1 && num <= ${#results[@]} )); then
        selected+=("${results[$((num-1))]}")
      else
        echo -e "${YELLOW}Invalid number: $num (skipping)${NC}"
  read -r -p "press enter to return"
      fi
    done
  fi
  if [[ ${#selected[@]} -eq 0 ]]; then
    echo -e "${RED}No valid selections.${NC}"
    return 1
  fi
  # Get destination.
  read -r -p "Local destination directory (default: script's directory): " dst
  # Strip enclosing single quotes if present (e.g., from drag-and-drop)
  if [[ ${dst:0:1} == "'" && ${dst: -1} == "'" ]]; then
    dst="${dst:1:-1}"
  fi
  dst="${dst:-$SCRIPT_DIR}"
  if [[ ! -d "$dst" ]]; then
    echo -e "${RED}Destination is not a directory: $dst${NC}"
    return 1
  fi
  local pulled_count=0
  for path in "${selected[@]}"; do
    echo -e "${GREEN}Pulling folder $path to $dst...${NC}"
    local local_path="$dst/$(basename "$path")"
    if $use_root; then
      # Root: Use tar to pull.
      adb shell "su -c 'tar cz -C \"$(dirname \"$path\")\" \"$(basename \"$path\")\" 2>/dev/null'" | (cd "$dst"; tar xz 2>/dev/null)
      if [[ ${PIPESTATUS[0]} -eq 0 && ${PIPESTATUS[1]} -eq 0 ]]; then
        if [[ -d "$local_path" && "$(ls -A "$local_path")" ]]; then
          echo -e "${GREEN}Successfully pulled $path and verified it exists locally.${NC}"
          ((pulled_count++))
        else
          echo -e "${RED}Pulled $path but verification failed.${NC}"
        fi
      else
        echo -e "${RED}Failed to pull $path${NC}"
      fi
    else
      # Normal: adb pull with timeout.
      if timeout 300 adb pull "$path" "$dst" >/dev/null 2>&1; then
        if [[ -d "$local_path" && "$(ls -A "$local_path")" ]]; then
          echo -e "${GREEN}Successfully pulled $path and verified it exists locally.${NC}"
          ((pulled_count++))
        else
          echo -e "${RED}Pulled $path but verification failed.${NC}"
        fi
      else
        echo -e "${RED}Failed to pull $path${NC}"
      fi
    fi
  done
  echo -e "${GREEN}Pulled $pulled_count folder(s) successfully.${NC}"
  read -r -p "Press Enter to return..."
}

# Push folder to device
# Pushes local folders to device (with root for restricted).
push_folder() {
  # Ensure device connected.
  check_device_connection || return 1
  local use_root=false
  # Prompt for root.
  if is_rooted; then
    read -r -p "Device is rooted. Use root privileges to push (allows restricted areas)? (y/n): " choice
    if [[ "$choice" == "y" || "$choice" == "Y" ]]; then
      use_root=true
    fi
  fi
  # Get source paths.
  read -r -p "Local folder paths (space-separated, quote paths with spaces): " src
  if [[ -z "$src" ]]; then
    return 1
  fi
  # Parse using eval for quoted paths.
  local folders=()
  if ! eval "folders=($src)" 2>/dev/null; then
    echo -e "${RED}Error parsing folder paths.${NC}"
    return 1
  fi
  if [ ${#folders[@]} -eq 0 ]; then
    echo -e "${RED}No valid folder paths provided.${NC}"
    return 1
  fi
  # Validate folders.
  local valid_folders=()
  for folder in "${folders[@]}"; do
    if [[ -d "$folder" ]]; then
      valid_folders+=("$folder")
    else
      echo -e "${RED}Local folder not found: $folder${NC}"
    fi
  done
  if [ ${#valid_folders[@]} -eq 0 ]; then
    return 1
  fi
  folders=("${valid_folders[@]}")
  # Get destination.
  read -r -p "Remote destination (default: /storage/emulated/0/Download/): " dst
  if [[ -z "$dst" ]]; then
    dst="/storage/emulated/0/Download/"
  fi
  # Ensure dir for multiple folders.
  if [ ${#folders[@]} -gt 1 ] && [[ ! "$dst" =~ /$ ]]; then
    dst="${dst}/"
    echo -e "${YELLOW}Appended / to destination for multiple folders.${NC}"
  fi
  # Validate destination path.
  if [[ ! "$dst" =~ ^/[a-zA-Z0-9_/.~-]+/?$ ]]; then
    echo -e "${RED}Invalid remote destination.${NC}"
    return 1
  fi
  # Warn about /sdcard symlink.
  if [[ "$dst" == "/sdcard/"* ]]; then
    echo -e "${YELLOW}Note: /sdcard is a symlink. Using /storage/emulated/0/ is more reliable.${NC}"
  fi
  echo -e "${GREEN}Pushing ${#folders[@]} folders to $dst...${NC}"
  local all_success=true
  local i=0
  for folder in "${folders[@]}"; do
    i=$((i + 1))
    local basename_folder=$(basename "$folder")
    local remote_path="$dst"
    if [[ "$dst" =~ /$ ]] || [ ${#folders[@]} -gt 1 ]; then
      remote_path="${dst}${basename_folder}"
    fi
    echo -e "${GREEN}Pushing $folder -> $remote_path...${NC}"
    local push_success=false
    if $use_root; then
      # Root push: Use temp dir and cp -r.
      local temp_path="/data/local/tmp/push_$$_${i}_temp"
      if adb push "$folder" "$temp_path" && \
         adb shell su -c "mkdir -p \"$remote_path\"" && \
         adb shell su -c "cp -r \"$temp_path/.\" \"$remote_path/\"" && \
         adb shell su -c "rm -r \"$temp_path\""; then
        push_success=true
      else
        echo -e "${RED}Failed to push $folder using root${NC}"
        adb shell su -c "rm -r \"$temp_path\"" &>/dev/null
        all_success=false
      fi
    else
      # Normal push with timeout.
      if timeout 300 adb push "$folder" "$remote_path"; then
        push_success=true
      else
        echo -e "${RED}Failed to push $folder${NC}"
        all_success=false
      fi
    fi
    if $push_success; then
      echo -e "${GREEN}Verifying folder presence on device...${NC}"
      local folder_exists=false
      if $use_root; then
        if adb shell su -c "[ -d \"$remote_path\" ]"; then
          folder_exists=true
        fi
      else
        if adb shell "[ -d \"$remote_path\" ]"; then
          folder_exists=true
        fi
      fi
      if $folder_exists; then
        echo -e "${GREEN}Folder confirmed on device at: $remote_path${NC}"
      else
        echo -e "${RED}Folder not found on device at: $remote_path (push may have failed silently or permissions issue)${NC}"
        all_success=false
      fi
    fi
  done
  if ! $all_success; then
    return 1
  fi
  read -r -p "Press Enter to return..."
}

# Delete folder from device
# Similar to delete_file, but for folders with rm -rf.
delete_folder() {
  # Escape helper.
  escape_single() {
    printf '%s' "$1" | sed "s/'/'\\''/g"
  }

  # Ensure connected.
  check_device_connection || return 1

  local use_root=false
  local search_paths="/storage/emulated/0/"
  local search_desc="In: /storage/emulated/0/"

  # Prompt root.
  if is_rooted; then
    read -r -p "Device is rooted. Search with root privileges (entire device)? (y/n): " choice
    if [[ "$choice" == "y" || "$choice" == "Y" ]]; then
      use_root=true
      search_paths="/"
      search_desc="In: entire device (using root privileges)"
    fi
  fi

  # Get pattern.
  read -r -p "Enter folder name to search (use * for wildcard, e.g. '*Music*'): " fname
  if [[ -z "$fname" ]]; then
    echo -e "${RED}No folder name provided.${NC}"
    return 1
  fi
  if [[ ! "$fname" == *'*'* ]]; then
    fname="*${fname}*"
  fi
  fname_escaped=$(escape_single "$fname")

  echo -e "${GREEN}Searching for folders matching: $fname${NC}"
  echo -e "${GREEN}$search_desc${NC}"
  local results=()
  # Search.
  if $use_root; then
    while IFS= read -r line; do results+=("$line"); done < <(adb shell "su -c \"find $search_paths -iname '$fname_escaped' -type d 2>/dev/null\"" | tr -d '\r')
  else
    while IFS= read -r line; do results+=("$line"); done < <(adb shell "for path in $search_paths; do if [ -d \"\$path\" ]; then find \"\$path\" -iname '$fname_escaped' -type d 2>/dev/null; fi; done" | tr -d '\r')
  fi
  if [[ ${#results[@]} -eq 0 ]]; then
    echo -e "${YELLOW}No folder with the name could be found.${NC}"
    read -r -p "Press Enter..."
    return 1
  fi
  # Display.
  echo -e "${GREEN}Found ${#results[@]} folder(s):${NC}"
  for i in "${!results[@]}"; do
    echo "$((i+1))) ${results[i]}"
  done
  # Selection.
  read -r -p "Select numbers to delete (space separated, or 'all'): " sel
  if [[ -z "$sel" ]]; then
    echo -e "${GREEN}No selection made.${NC}"
    return 0
  fi
  local selected=()
  if [[ "$sel" == "all" ]]; then
    selected=("${results[@]}")
  else
    for num in $sel; do
      if [[ $num =~ ^[0-9]+$ ]] && (( num >= 1 && num <= ${#results[@]} )); then
        selected+=("${results[$((num-1))]}")
      else
        echo -e "${YELLOW}Invalid number: $num (skipping)${NC}"
      fi
    done
  fi
  if [[ ${#selected[@]} -eq 0 ]]; then
    echo -e "${RED}No valid selections.${NC}"
    return 1
  fi
  # Confirm.
  echo -e "${YELLOW}Selected folders to delete:${NC}"
  for path in "${selected[@]}"; do
    echo "  $path"
  done
  read -r -p "Confirm deletion of these ${#selected[@]} folders and their contents? (y/N): " confirm
  if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
    echo -e "${GREEN}Deletion canceled.${NC}"
    return 0
  fi
  local deleted_count=0
  for path in "${selected[@]}"; do
    local path_escaped=$(escape_single "$path")
    echo -e "${GREEN}Deleting folder $path...${NC}"
    local delete_cmd="rm -rf '${path_escaped}' 2>/dev/null"
    if $use_root; then
      delete_cmd="su -c \"$delete_cmd\""
    fi
    adb shell "$delete_cmd"
    # Verify.
    local check_cmd="[ -d '${path_escaped}' ] && echo exists || echo deleted"
    if $use_root; then
      check_cmd="su -c \"$check_cmd\""
    fi
    local status=$(adb shell "$check_cmd" | tr -d '\r')
    if [[ "$status" == "deleted" ]]; then
      ((deleted_count++))
      echo -e "${GREEN}Successfully deleted $path (verified).${NC}"
    else
      echo -e "${RED}Failed to delete $path (still exists).${NC}"
    fi
  done
  echo -e "${GREEN}Deleted $deleted_count folder(s) successfully.${NC}"
  read -r -p "Press Enter to return..."
}

# Search for folders on device
# Searches and lists folders matching pattern (with root option).
find_folder() {
  # Ensure connected.
  check_device_connection || return 1

  local use_root=false
  local search_paths="/storage/emulated/0/"
  local search_desc="In: /storage/emulated/0/"

  # Prompt root.
  if is_rooted; then
    read -r -p "Device is rooted. Search with root privileges (expanded to entire device)? (y/n): " choice
    if [[ "$choice" == "y" || "$choice" == "Y" ]]; then
      use_root=true
      search_paths="/"
      search_desc="In: entire device (using root privileges)"
    fi
  fi

  # Get pattern.
  read -r -p "Enter folder name to search (use * for wildcard, e.g. '*Music*'): " fname
  if [[ -z "$fname" ]]; then
    echo -e "${RED}No folder name provided.${NC}"
    return 1
  fi

  # Add wildcards if missing.
  if [[ ! "$fname" == *'*'* ]]; then
    fname="*${fname}*"
  fi

  # Escape.
  fname_escaped=$(printf '%s' "$fname" | sed "s/'/'\\''/g")

  echo -e "${GREEN}Searching for folders matching: $fname${NC}"
  echo -e "${GREEN}$search_desc${NC}"

  local results
  # Search.
  if $use_root; then
    results=$(adb shell "su -c \"find / -iname '$fname_escaped' -type d 2>/dev/null\"" | tr -d '\r')
  else
    results=$(adb shell "for path in $search_paths; do
                        if [ -d \"\$path\" ]; then
                          find \"\$path\" -iname '$fname_escaped' -type d 2>/dev/null
                        fi
                      done" | tr -d '\r')
  fi

  # Display results.
  if [[ -n "$results" ]]; then
    echo "$results"
    local count=$(echo "$results" | wc -l)
    echo -e "${GREEN}Search complete. Found $count folder(s).${NC}"
  else
    echo -e "${YELLOW}No matching folders found.${NC}"
  fi

  read -r -p "Press enter to return to the menu..."
}

# Search for files on device
# Similar to find_folder, but for files.
find_file() {
  # Ensure connected.
  check_device_connection || return 1

  local use_root=false
  local search_paths="/storage/emulated/0/"
  local search_desc="In: /storage/emulated/0/"

  # Prompt root.
  if is_rooted; then
    read -r -p "Device is rooted. Search with root privileges (expanded to entire device)? (y/n): " choice
    if [[ "$choice" == "y" || "$choice" == "Y" ]]; then
      use_root=true
      search_paths="/"
      search_desc="In: entire device (using root privileges)"
    fi
  fi

  # Get pattern.
  read -r -p "Enter filename to search (use * for wildcard, e.g. '*.mp4'): " fname
  if [[ -z "$fname" ]]; then
    echo -e "${RED}No filename provided.${NC}"
    return 1
  fi

  # Add wildcards.
  if [[ ! "$fname" == *'*'* ]]; then
    fname="*${fname}*"
  fi

  # Escape.
  fname_escaped=$(printf '%s' "$fname" | sed "s/'/'\\''/g")

  echo -e "${GREEN}Searching for files matching: $fname${NC}"
  echo -e "${GREEN}$search_desc${NC}"

  local results
  # Search.
  if $use_root; then
    results=$(adb shell "su -c \"find / -iname '$fname_escaped' -type f 2>/dev/null\"" | tr -d '\r')
  else
    results=$(adb shell "for path in $search_paths; do
                        if [ -d \"\$path\" ]; then
                          find \"\$path\" -iname '$fname_escaped' -type f 2>/dev/null
                        fi
                      done" | tr -d '\r')
  fi

  # Display.
  if [[ -n "$results" ]]; then
    echo "$results"
    local count=$(echo "$results" | wc -l)
    echo -e "${GREEN}Search complete. Found $count file(s).${NC}"
  else
    echo -e "${YELLOW}No matching files found.${NC}"
  fi

  read -r -p "Press enter to return to menu..."
}

# =============================================================================
# DEVELOPER TOOLS FUNCTIONS
# =============================================================================

# Logcat options menu
# Provides a menu for logcat-related functions.
logcat_options() {
  local choice

  # Inner function: Displays logcat with optional filter.
logcat_viewer() {
    local filter filter_spec
    echo -e "${YELLOW}Available filter types:${NC}"
    echo "   Leave empty  show all logs"
    echo "   Start with 'logcat:'  native logcat filter (e.g. logcat:*:E or logcat MyTag:I)"
    echo "   Anything else  grep search (case-insensitive, regex supported)"
    echo

    read -r -p "Filter (optional): " filter
    check_device_connection || return 1

    echo -e "${CYAN}Press Ctrl+C to stop viewing logs and return to the menu.${NC}"
    echo "Press Enter to start..."
    read -r

    trap 'echo -e "\n${RED}Logcat interrupted. Returning to menu.${NC}"; trap - SIGINT; return 0' SIGINT

    # Case 1: No filter
    if [[ -z "$filter" ]]; then
        adb logcat || { echo -e "${RED}Failed to display logcat${NC}"; trap - SIGINT; return 1; }
        trap - SIGINT
        return
    fi

    # Case 2: Native logcat filter (starts with "logcat:")
    if [[ "$filter" == logcat:* ]]; then
        filter_spec="${filter#logcat:}"
        filter_spec="${filter_spec##[[:space:]]}"  # trim leading space

        # Very basic validation of native filter spec
        if [[ -z "$filter_spec" ]] || ! [[ "$filter_spec" =~ ^[A-Za-z0-9_*:\.\-]+$ ]]; then
            echo -e "${RED}Invalid native logcat filter syntax!${NC}"
            echo "Examples of valid filters:"
            echo "  logcat:*:E            only errors"
            echo "  logcat:MyTag:V        verbose for MyTag"
            echo "  logcat MyTag:I *:S    info+ for MyTag, silent everything else"
            echo -e "\n${YELLOW}Press Enter to return...${NC}"
            read -r
            trap - SIGINT
            return 1
        fi

        echo -e "${GREEN}Using native logcat filter: $filter_spec${NC}"
        adb logcat "$filter_spec" || {
            echo -e "${RED}Failed to display filtered logcat${NC}"
            trap - SIGINT
            return 1
        }
        trap - SIGINT
        return
    fi

    # Case 3: Grep-style filter (everything else)
    echo -e "${GREEN}Using grep filter (case-insensitive):${NC} ${MAGENTA}$filter${NC}"
    echo -e "${YELLOW}Showing only lines matching your filter...${NC}"

    # Use timeout + pipeline to detect when nothing matches for a while
    if ! adb logcat | grep -i -E --color=always -- "$filter" | \
    while IFS= read -r line; do
        echo "$line"
        printed=1   # we saw at least one match
    done; then
        echo -e "${RED}adb logcat command failed or was interrupted${NC}"
    fi

    # After pipeline ends (Ctrl+C or error), check if we printed anything
    if [[ -z "${printed:-}" ]]; then
        echo -e "\n${RED}Nothing found that matches your filter:${NC} ${MAGENTA}$filter${NC}"
        echo -e "${YELLOW}Press Enter to return to the menu...${NC}"
        read -r
    fi

    trap - SIGINT
}

# Inner function: Dumps current logcat to a timestamped file.
logcat_save() {
  # Get script directory (works when script is executed directly)
  local SCRIPT_DIR=$(dirname "$(realpath "$0")")
  # Prompt for custom path
  read -r -p "Enter custom path to save logcat (leave empty for script directory): " custom_path
  # Remove leading and trailing single quotes if present
  custom_path="${custom_path#\'}"
  custom_path="${custom_path%\'}"
  if [[ -z "$custom_path" ]]; then
    custom_path="$SCRIPT_DIR"
  fi
  # Check if directory exists
  if [[ ! -d "$custom_path" ]]; then
    echo -e "${RED}Invalid directory: $custom_path${NC}"
      echo -e "Press enter to return"
      read -r
    return 1
  fi
  # Check write permission in directory
  if [[ ! -w "$custom_path" ]]; then
    echo -e "${RED}No write permission in directory: $custom_path${NC}"
      echo -e "Press enter to return"
      read -r
    return 1
  fi
  # Prompt user for custom name (optional)
  read -r -p "Enter custom name for the logcat file (optional, press Enter for none): " customname
  # Generate timestamp once
  local timestamp=$(date +%Y%m%d_%H%M%S)
  # Build custom part only if user provided something usable
  local custom_part=""
  if [[ -n "$customname" ]]; then
    # Sanitize: only allow letters, numbers, underscore, hyphen  everything else becomes _
    local sanitized=$(echo "$customname" | sed 's/[^a-zA-Z0-9_-]/_/g')
    # Only use it if there's at least one letter or number (prevents "_", "___", etc.)
    if [[ "$sanitized" =~ [a-zA-Z0-9] ]]; then
      custom_part="_${sanitized}"
    fi
  fi
  # Generate filename exactly like before when no custom name, otherwise logcat_customname_timestamp_pid.txt
  local fname="logcat${custom_part}_${timestamp}_$$.txt"
  # Validate filename (basename only)
  if ! [[ "$fname" =~ ^[a-zA-Z0-9_/.~-]+$ ]]; then
    # This will never fail now due to sanitization, but kept for safety
    echo -e "${RED}Generated filename contains invalid characters: $fname${NC}"
      echo -e "Press enter to return"
      read -r
    return 1
  fi
  local full_fname="$custom_path/$fname"
  # Test file creation
  if ! touch "$full_fname" 2>/dev/null; then
    echo -e "${RED}Cannot create file: $full_fname${NC}"
      echo -e "Press enter to return"
      read -r
    return 1
  fi
  rm -f "$full_fname" # clean up test file
  check_device_connection || return 1
  echo -e "${GREEN}Saving logcat  $fname${NC}"


  # Dump logcat
  if adb logcat -d > "$full_fname" 2>/dev/null; then
    if [[ -s "$full_fname" ]]; then
      echo -e "${GREEN}Logcat successfully saved to:$NC"
      echo -e "${CYAN}$full_fname${NC}"
      echo -e "Press enter to return"
      read -r
      return 0
    else
      echo -e "${RED}Logcat is empty  file will be deleted${NC}"
      rm -f "$full_fname"
      echo -e "Press enter to return"
      read -r
      return 1
    fi
  else
    echo -e "${RED}Failed to save logcat${NC}"
      echo -e "Press enter to return"
      read -r
    rm -f "$full_fname"
    sleep 2
    return 1
  fi
}

  # Inner function: Clears the logcat buffer.
  logcat_clear() {
    check_device_connection || return 1
    if adb logcat -c; then
      echo -e "${GREEN}Logcat cleared successfully.${NC}"
    else
      echo -e "${RED}Failed to clear logcat.${NC}"
      return 1
    fi
    read -r -p "Press Enter to return..."
  }

  while true; do
    clear
    echo "1) View Logcat"
    echo "2) Save Logcat"
    echo "3) Clear Logcat"
    echo "4) back"
    read -r -p "Enter your choice: " choice

    case "$choice" in
      1) logcat_viewer ;;
      2) logcat_save ;;
      3) logcat_clear ;;
      4) return 0 ;;
      *) echo -e "${RED}Invalid choice. Please try again.${NC}" ;;
    esac
  done
}

# Shell access
# Opens an interactive ADB shell.
shell_access() { 
  check_device_connection || return 1
  adb shell || { echo -e "${RED}Failed to open shell${NC}"; return 1; }; 
}

# Custom ADB command
# Executes user-provided ADB command.
custom_adb_command() {
  check_device_connection || return 1
  read -r -p "Enter ADB command (without 'adb ' prefix, e.g. 'shell ls /sdcard'): " cmd
  if [[ -z "$cmd" ]]; then
    echo -e "${RED}No command entered.${NC}"
    return 1
  fi
  echo -e "${GREEN}Executing: adb $cmd${NC}"
  adb $cmd || { echo -e "${RED}Command failed.${NC}"; return 1; }
  read -r -p "Press Enter to return..."
}

# =============================================================================
# CUSTOM SETTINGS FUNCTIONS
# =============================================================================

# TV tweaks
# Applies performance tweaks for TV devices (animations, caches, etc.), with reboot.
tv_tweaks() {
  check_device_connection || return 1
  # Check SDK level.
  local sdk=$(adb shell getprop ro.build.version.sdk 2>/dev/null | tr -d '\r' | xargs)
  if [[ "$sdk" -lt 28 ]]; then
    echo -e "${RED}This function is only for Android 9 (API 28) and above. Your device is API $sdk.${NC}"
    return 1
  fi
  echo -e "${YELLOW}Detected Android API level: $sdk.${NC}"
  echo -e "${RED}Warning: This could damage your device. Use at your own risk.${NC}"
  read -r -p "Do you want to proceed? (y/n): " confirm
  case "$confirm" in
    y|Y ) ;;
    n|N ) echo -e "${YELLOW}Returning to menu.${NC}"; return 0 ;;
    * ) echo -e "${YELLOW}Invalid choice. Returning to menu.${NC}"; return 0 ;;
  esac
  echo -e "${GREEN}Applying TV tweaks for performance improvements...${NC}"
  echo -e "${YELLOW}This may take a while.${NC}"
  local success_count=0
  local total=0
  # Background dexopt.
  ((total++))
  if adb shell cmd package bg-dexopt-job &>/dev/null; then
    ((success_count++))
    echo -e "${GREEN}Background dexopt job completed.${NC}"
  else
    echo -e "${YELLOW}Failed to run background dexopt (may not be supported).${NC}"
  fi
  # Disable animations.
  ((total++))
  if adb shell settings put global window_animation_scale 0.0 &>/dev/null; then
    ((success_count++))
    echo -e "${GREEN}Disabled window animations.${NC}"
  else
    echo -e "${YELLOW}Failed to disable window animations${NC}";
  fi
  ((total++))
  if adb shell settings put global transition_animation_scale 0.0 &>/dev/null; then
    ((success_count++))
    echo -e "${GREEN}Disabled transition animations.${NC}"
  else
    echo -e "${YELLOW}Failed to disable transition animations${NC}";
  fi
  ((total++))
  if adb shell settings put global animator_duration_scale 0.0 &>/dev/null; then
    ((success_count++))
    echo -e "${GREEN}Disabled animator duration.${NC}"
  else
    echo -e "${YELLOW}Failed to disable animator duration${NC}";
  fi
  # Android 12+ tweaks.
  if [[ "$sdk" -ge 31 ]]; then
    ((total++))
    if adb shell settings put global disable_window_blurs 1 &>/dev/null; then
      ((success_count++))
      echo -e "${GREEN}Disabled window blurs.${NC}"
    else
      echo -e "${YELLOW}Failed to disable window blurs (may not be supported)${NC}";
    fi
    ((total++))
    if adb shell settings put global accessibility_reduce_transparency 1 &>/dev/null; then
      ((success_count++))
      echo -e "${GREEN}Reduced transparency.${NC}"
    else
      echo -e "${YELLOW}Failed to reduce transparency (may not be supported)${NC}";
    fi
  else
    echo -e "${YELLOW}Skipping window blurs and transparency tweaks (requires Android 12+)${NC}"
  fi
  # Trim caches.
  ((total++))
  if adb shell pm trim-caches 999G &>/dev/null; then
    ((success_count++))
    echo -e "${GREEN}Trimmed app caches.${NC}"
  else
    echo -e "${YELLOW}Failed to trim app caches (may not be supported)${NC}";
  fi
  if [[ $success_count -eq $total ]]; then
    echo -e "${GREEN}All TV tweaks applied successfully.${NC}"
    echo -e "${GREEN}All Tweaks are successfully applied device needs a reboot press enter to reboot${NC}"
    read -r -p ""
    echo -e "${GREEN}Rebooting device...${NC}"
    adb reboot
    exit 0
  elif [[ $success_count -gt 0 ]]; then
    echo -e "${YELLOW}Applied $success_count out of $total tweaks (some may not be supported on your device).${NC}"
    echo -e "${GREEN}Device needs a reboot. Press enter to reboot.${NC}"
    read -r -p ""
    echo -e "${GREEN}Rebooting device...${NC}"
    adb reboot
    exit 0
  else
    echo -e "${RED}Failed to apply any TV tweaks.${NC}"
    read -r -p "Press Enter to return to menu..."
  fi
}

# DNS settings
# Menu to set private DNS provider.
dns_settings() {
  check_device_connection || return 1
  while true; do
    echo -e "${GREEN}Set private DNS:${NC}"
    # Get current settings.
    local current_mode=$(adb shell settings get global private_dns_mode 2>/dev/null | tr -d '\r')
    local current_specifier=$(adb shell settings get global private_dns_specifier 2>/dev/null | tr -d '\r')
    echo -e "${YELLOW}Current mode: ${current_mode:-off}${NC}"
    echo -e "${YELLOW}Current specifier: ${current_specifier:-None}${NC}"
    echo "1) Disable private DNS (default)"
    echo "2) Enable Cloudflare private DNS (one.one.one.one)"
    echo "3) Enable Mullvad private DNS (base.dns.mullvad.net)"
    echo "4) Enable AdGuard private DNS (dns.adguard.com)"
    echo "5) Enable ControlD private DNS (p2.freedns.controld.com)"
    echo "6) Enable Quad9 private DNS (dns.quad9.net)"
    echo "7) Enable Custom private DNS"
    echo "8) Back"
    read -r -p "Choose (1-8): " choice
    case $choice in
      1)
        # Disable.
        adb shell settings put global private_dns_mode off &>/dev/null
        adb shell settings delete global private_dns_specifier &>/dev/null
        local new_mode=$(adb shell settings get global private_dns_mode 2>/dev/null | tr -d '\r')
        local new_specifier=$(adb shell settings get global private_dns_specifier 2>/dev/null | tr -d '\r')
        if [[ "$new_mode" == "off" ]] && ([[ -z "$new_specifier" ]] || [[ "$new_specifier" == "null" ]]); then
          echo -e "${GREEN}DNS has been successfully disabled. Press Enter to reboot.${NC}"
          read -r -p ""
          adb reboot &>/dev/null
          echo -e "${GREEN}Rebooting device...${NC}"
          exit 0
        else
          echo -e "${RED}DNS could not be set. Maybe not supported on your device.${NC}"
          read -r -p "Press enter to return..."
        fi
        ;;
      2)
        # Cloudflare.
        adb shell settings put global private_dns_mode hostname &>/dev/null
        adb shell settings put global private_dns_specifier one.one.one.one &>/dev/null
        local new_mode=$(adb shell settings get global private_dns_mode 2>/dev/null | tr -d '\r')
        local new_specifier=$(adb shell settings get global private_dns_specifier 2>/dev/null | tr -d '\r')
        if [[ "$new_mode" == "hostname" ]] && [[ "$new_specifier" == "one.one.one.one" ]]; then
          echo -e "${GREEN}DNS change was successful. Press enter to reboot.${NC}"
          read -r -p ""
          adb reboot &>/dev/null
          echo -e "${GREEN}Rebooting device...${NC}"
          exit 0
        else
          echo -e "${RED}DNS could not be set. Maybe not supported on your device.${NC}"
          read -r -p "Press enter to return..."
        fi
        ;;
      3)
        # Mullvad.
        adb shell settings put global private_dns_mode hostname &>/dev/null
        adb shell settings put global private_dns_specifier base.dns.mullvad.net &>/dev/null
        local new_mode=$(adb shell settings get global private_dns_mode 2>/dev/null | tr -d '\r')
        local new_specifier=$(adb shell settings get global private_dns_specifier 2>/dev/null | tr -d '\r')
        if [[ "$new_mode" == "hostname" ]] && [[ "$new_specifier" == "base.dns.mullvad.net" ]]; then
          echo -e "${GREEN}DNS change was successful. Press enter to reboot.${NC}"
          read -r -p ""
          adb reboot &>/dev/null
          echo -e "${GREEN}Rebooting device...${NC}"
          exit 0
        else
          echo -e "${RED}DNS could not be set. Maybe not supported on your device.${NC}"
          read -r -p "Press enter to return..."
        fi
        ;;
      4)
        # AdGuard.
        adb shell settings put global private_dns_mode hostname &>/dev/null
        adb shell settings put global private_dns_specifier dns.adguard.com &>/dev/null
        local new_mode=$(adb shell settings get global private_dns_mode 2>/dev/null | tr -d '\r')
        local new_specifier=$(adb shell settings get global private_dns_specifier 2>/dev/null | tr -d '\r')
        if [[ "$new_mode" == "hostname" ]] && [[ "$new_specifier" == "dns.adguard.com" ]]; then
          echo -e "${GREEN}DNS change was successful. Press enter to reboot.${NC}"
          read -r -p ""
          adb reboot &>/dev/null
          echo -e "${GREEN}Rebooting device...${NC}"
          exit 0
        else
          echo -e "${RED}DNS could not be set. Maybe not supported on your device.${NC}"
          read -r -p "Press enter to return..."
        fi
        ;;
      5)
        # ControlD.
        adb shell settings put global private_dns_mode hostname &>/dev/null
        adb shell settings put global private_dns_specifier p2.freedns.controld.com &>/dev/null
        local new_mode=$(adb shell settings get global private_dns_mode 2>/dev/null | tr -d '\r')
        local new_specifier=$(adb shell settings get global private_dns_specifier 2>/dev/null | tr -d '\r')
        if [[ "$new_mode" == "hostname" ]] && [[ "$new_specifier" == "p2.freedns.controld.com" ]]; then
          echo -e "${GREEN}DNS change was successful. Press enter to reboot.${NC}"
          read -r -p ""
          adb reboot &>/dev/null
          echo -e "${GREEN}Rebooting device...${NC}"
          exit 0
        else
          echo -e "${RED}DNS could not be set. Maybe not supported on your device.${NC}"
          read -r -p "Press enter to return..."
        fi
        ;;
      6)
        # Quad9.
        adb shell settings put global private_dns_mode hostname &>/dev/null
        adb shell settings put global private_dns_specifier dns.quad9.net &>/dev/null
        local new_mode=$(adb shell settings get global private_dns_mode 2>/dev/null | tr -d '\r')
        local new_specifier=$(adb shell settings get global private_dns_specifier 2>/dev/null | tr -d '\r')
        if [[ "$new_mode" == "hostname" ]] && [[ "$new_specifier" == "dns.quad9.net" ]]; then
          echo -e "${GREEN}DNS change was successful. Press enter to reboot.${NC}"
          read -r -p ""
          adb reboot &>/dev/null
          echo -e "${GREEN}Rebooting device...${NC}"
          exit 0
        else
          echo -e "${RED}DNS could not be set. Maybe not supported on your device.${NC}"
          read -r -p "Press enter to return..."
        fi
        ;;
      7)
        # Custom.
        read -r -p "Enter custom DNS hostname (e.g., dns.example.com): " custom_specifier
        if [[ -z "$custom_specifier" ]]; then
          echo -e "${RED}No hostname entered. Returning to menu.${NC}"
          continue
        fi
        adb shell settings put global private_dns_mode hostname &>/dev/null
        adb shell settings put global private_dns_specifier "$custom_specifier" &>/dev/null
        local new_mode=$(adb shell settings get global private_dns_mode 2>/dev/null | tr -d '\r')
        local new_specifier=$(adb shell settings get global private_dns_specifier 2>/dev/null | tr -d '\r')
        if [[ "$new_mode" == "hostname" ]] && [[ "$new_specifier" == "$custom_specifier" ]]; then
          echo -e "${GREEN}DNS change was successful. Press enter to reboot.${NC}"
          read -r -p ""
          adb reboot &>/dev/null
          echo -e "${GREEN}Rebooting device...${NC}"
          exit 0
        else
          echo -e "${RED}DNS could not be set. Maybe not supported on your device.${NC}"
          read -r -p "Press enter to return..."
        fi
        ;;
      8)
        return 0
        ;;
      *)
        echo -e "${RED}Invalid choice.${NC}"
        ;;
    esac
  done
}

# Take screenshot
# Captures and saves a screenshot to script dir.
screenshot() {
  SCRIPT_DIR=$(dirname "$(realpath "$0")")
  # Prompt for custom path
  read -r -p "Enter custom path to save screenshot (leave empty for script directory): " custom_path
  # Automatically remove leading and trailing single quotes if present
  custom_path=${custom_path#\'}
  custom_path=${custom_path%\'}
  if [[ -z "$custom_path" ]]; then
    custom_path="$SCRIPT_DIR"
  fi
  # Check if directory exists
  if [[ ! -d "$custom_path" ]]; then
    echo -e "${RED}Invalid directory: $custom_path${NC}"
    return 1
  fi
  # Check write permission.
  if [[ ! -w "$custom_path" ]]; then
    echo -e "${RED}No write permission in directory: $custom_path${NC}"
    return 1
  fi
  # Generate filename.
  local fname="$custom_path/screenshot_$(date +%Y%m%d_%H%M%S)_$$.png"
  check_device_connection || return 1
  echo -e "${GREEN}Capturing screenshot...${NC}"
  # Capture.
  if adb exec-out screencap -p > "$fname" 2>/dev/null; then
    if [[ -s "$fname" ]]; then
      echo -e "${GREEN}Screenshot saved as $fname${NC}"
    else
      echo -e "${RED}Screenshot failed: file is empty${NC}"
      rm -f "$fname"
      return 1
    fi
  else
    echo -e "${RED}Failed to capture screenshot${NC}"
    rm -f "$fname"
    return 1
  fi
  read -r -p "Press Enter to return..."
}

# Check for updates
# Opens system update settings on device.
check_for_updates() {
  check_device_connection || return 1
  echo -e "${GREEN}Checking for updates...${NC}"
  adb shell am start -a android.settings.SYSTEM_UPDATE_SETTINGS || { echo -e "${RED}Failed to open update settings${NC}"; return 1; }
  echo -e "${GREEN}Update settings opened on device. Check manually.${NC}"
  read -r -p "Press Enter to return..."
}

# =============================================================================
# MENU FUNCTIONS
# =============================================================================

# Main menu
# Loops to display main categories.
main_menu() {
  while true; do
    (tput clear 2>/dev/null) || printf '\033[2J\033[H'
    echo -e "\n${RED}DroidSuite Main Menu${NC}"
    echo -e
    echo "1) Device Info"
    echo "2) App Management"
    echo "3) File Management"
    echo "4) Custom Settings"
    echo "5) Developer Tools"
    echo "6) Exit"
    read -r -p "Select category (1-6): " cat
    case $cat in
      1) show_device_report ;;
      2) category_app_mgmt ;;
      3) category_files ;;
      4) custom_settings_menu ;;
      5) category_dev_tools ;;
      6) echo -e "${GREEN}Goodbye!${NC}"; exit 0 ;;
      *) echo -e "${RED}Invalid choice.${NC}" ;;
    esac
  done
}

# App management category menu
category_app_mgmt() {
  while true; do
    clear
    echo -e "\n${RED}App Management:${NC}"
    echo -e
    echo "1) Install apps"
    echo "2) Uninstall apps"
    echo "3) Enable/disable apps"
    echo "4) Delete app data and cache (per app)"
    echo "5) Clear only cache (aio)"
    echo "6) Back to main menu"
    read -r -p "Choose (1-6): " c
    case $c in
      1) install_apps ;;
      2) uninstall_apps ;;
      3) enable_disable_app ;;
      4) delete_app_data_cache ;;
      5) cache_clear ;;
      6) break ;;
      *) echo -e "${RED}Invalid choice.${NC}" ;;
    esac
  done
}

# File management category menu
category_files() {
  while true; do
    clear
    echo -e "\n${RED}File Management:${NC}"
    echo -e
    echo "1) Pull file from device"
    echo "2) Pull folder from device"
    echo "3) Push file to device"
    echo "4) Push folder to device"
    echo "5) Delete file from device"
    echo "6) Delete folder from device"
    echo "7) Search for files on device"
    echo "8) Search for folders on device"
    echo "9) Back to main menu"
    read -r -p "Choose (1-9): " c
    case $c in
      1) pull_file ;;
      2) pull_folder ;;
      3) push_file ;;
      4) push_folder ;;
      5) delete_file ;;
      6) delete_folder ;;
      7) find_file ;;
      8) find_folder ;;
      9) break ;;
      *) echo -e "${RED}Invalid choice.${NC}" ;;
    esac
  done
}

# Custom settings category menu
custom_settings_menu() {
  while true; do
    clear
    echo -e "\n${RED}Custom Settings:${NC}"
    echo -e
    echo "1) TV Tweaks"
    echo "2) DNS Settings"
    echo "3) Take Screenshot"
    echo "4) Check for updates"
    echo "5) Back to main menu"
    read -r -p "Choose (1-5): " c
    case $c in
      1) tv_tweaks ;;
      2) dns_settings ;;
      3) screenshot ;;
      4) check_for_updates ;;
      5) break ;;
      *) echo -e "${RED}Invalid choice.${NC}" ;;
    esac
  done
}

# Developer tools category menu
category_dev_tools() {
  while true; do
    clear
    echo -e "\n${RED}Developer Tools:${NC}"
    echo -e
    echo "1) Logcat Options"
    echo "2) Open shell"
    echo "3) Custom ADB command"
    echo "4) Back to main menu"
    read -r -p "Choose (1-4): " c
    case $c in
      1) logcat_options ;;
      2) shell_access ;;
      3) custom_adb_command ;;
      4) break ;;
      *) echo -e "${RED}Invalid choice.${NC}" ;;
    esac
  done
}

# =============================================================================
# SCRIPT EXECUTION START
# =============================================================================

# Check for ADB.
check_for_adb
# Show connection menu.
connection_menu
# Enter main menu loop.
main_menu
